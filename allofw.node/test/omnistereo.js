// Generated by CoffeeScript 1.10.0
(function() {
  var GL, allofw, allofwutils, compileShaders, composite_custom_shader, composite_shader_id, fragment_shader, getProgramInfoLog, getShaderInfoLog, nav, omni, render, setupBuffers, setupRender, timer, vertex_shader, w;

  allofw = require("allofw");

  allofwutils = require("allofwutils");

  GL = allofw.GL3;

  w = new allofw.OpenGLWindow();

  w.makeContextCurrent();

  omni = new allofw.OmniStereo("allofw.yaml");

  nav = new allofwutils.WindowNavigation(w, omni);

  vertex_shader = "#version 330\n" + omni.getShaderCode() + "layout(location = 0) in vec3 position;\nlayout(location = 1) in vec3 color;\nout vec3 Color;\nvoid main() {\n    Color = color;\n    gl_Position = omni_render(omni_transform(position));\n}";

  fragment_shader = "#version 330\n" + "in vec3 Color;\nlayout(location = 0) out vec4 outputF;\nvoid main() {\n    outputF = vec4(Color, 1.0);\n}";

  composite_custom_shader = "uniform vec2 viewport_angles = vec2(50, 40);\nuniform float viewport_blur = 1;\nuniform vec3 viewport_y = vec3(0, 1, 0);\nuniform vec3 viewport_x = vec3(1, 0, 0);\n\nvec4 viewport_restrict(vec4 color) {\n    float blur = 1.0 / (viewport_blur / 180.0 * PI);\n    vec2 xyspan = viewport_angles / 180.0 * PI;\n    vec2 xyangle = vec2(acos(dot(normalize(warp - warp * dot(warp, viewport_y)), viewport_x)),\n                        acos(dot(normalize(warp - warp * dot(warp, viewport_x)), viewport_y)));\n    vec2 xyscale = vec2(1, 1) - max(vec2(0, 0), min(vec2(1, 1), (xyspan / 2.0 - abs(xyangle - PI / 2.0)) * blur));\n    return color * (1 - dot(xyscale, xyscale));\n}\n\nvoid main() {\n    omni_composite_init();\n    vec4 scene = omni_composite_scene();\n    scene = viewport_restrict(scene);\n    if((drawMask & kCompositeMask_Panorama) != 0) {\n        vec4 panorama = omni_composite_panorama();\n        scene = omni_blend_pm(scene, panorama);\n    }\n    omni_composite_final(scene);\n}";

  composite_shader_id = omni.compositeCustomizeShader(composite_custom_shader);

  getShaderInfoLog = function(shader) {
    var buf, buffer, length;
    buffer = new Buffer(4);
    GL.getShaderiv(shader, GL.INFO_LOG_LENGTH, buffer);
    length = buffer.readUInt32LE(0);
    if (length > 0) {
      buf = new Buffer(length);
      GL.getShaderInfoLog(shader, length, buffer, buf);
      return buf.toString("utf-8");
    }
  };

  getProgramInfoLog = function(program) {
    var buf, buffer, length;
    buffer = new Buffer(4);
    GL.getProgramiv(program, GL.INFO_LOG_LENGTH, buffer);
    length = buffer.readUInt32LE(0);
    if (length > 0) {
      buf = new Buffer(length);
      GL.getProgramInfoLog(program, length, buffer, buf);
      return buf.toString("utf-8");
    } else {
      return null;
    }
  };

  compileShaders = function() {
    var log, shader_f, shader_v;
    shader_v = GL.createShader(GL.VERTEX_SHADER);
    GL.shaderSource(shader_v, [vertex_shader]);
    shader_f = GL.createShader(GL.FRAGMENT_SHADER);
    GL.shaderSource(shader_f, [fragment_shader]);
    this.program = GL.createProgram();
    GL.compileShader(shader_v);
    log = getShaderInfoLog(shader_v);
    if (log != null) {
      console.log(log);
    }
    GL.compileShader(shader_f);
    log = getShaderInfoLog(shader_f);
    if (log != null) {
      console.log(log);
    }
    GL.attachShader(program, shader_v);
    GL.attachShader(program, shader_f);
    GL.bindFragDataLocation(program, 0, "outputF");
    GL.linkProgram(program);
    log = getProgramInfoLog(program);
    if (log != null) {
      return console.log(log);
    }
  };

  setupBuffers = function() {
    var cube, i, j, k, vertices, vertices_array, x, y, z;
    this.vertex_buffer = new GL.Buffer();
    this.vertex_array = new GL.VertexArray();
    vertices = [];
    cube = function(x, y, z, size) {
      var c0, c1, insert, v0, v1, v2, v3, v4, v5, v6, v7;
      c0 = 0.3;
      c1 = 0.7;
      v0 = [x - size / 2, y - size / 2, z - size / 2, c0, c0, c0];
      v1 = [x - size / 2, y - size / 2, z + size / 2, c0, c0, c1];
      v2 = [x - size / 2, y + size / 2, z - size / 2, c0, c1, c0];
      v3 = [x - size / 2, y + size / 2, z + size / 2, c0, c1, c1];
      v4 = [x + size / 2, y - size / 2, z - size / 2, c1, c0, c0];
      v5 = [x + size / 2, y - size / 2, z + size / 2, c1, c0, c1];
      v6 = [x + size / 2, y + size / 2, z - size / 2, c1, c1, c0];
      v7 = [x + size / 2, y + size / 2, z + size / 2, c1, c1, c1];
      insert = function(x) {
        vertices.push(x[0]);
        vertices.push(x[1]);
        vertices.push(x[2]);
        vertices.push(x[3]);
        vertices.push(x[4]);
        return vertices.push(x[5]);
      };
      insert(v0);
      insert(v1);
      insert(v3);
      insert(v0);
      insert(v3);
      insert(v2);
      insert(v3);
      insert(v1);
      insert(v5);
      insert(v3);
      insert(v5);
      insert(v7);
      insert(v3);
      insert(v7);
      insert(v6);
      insert(v3);
      insert(v6);
      insert(v2);
      insert(v1);
      insert(v0);
      insert(v4);
      insert(v1);
      insert(v4);
      insert(v5);
      insert(v5);
      insert(v4);
      insert(v6);
      insert(v5);
      insert(v6);
      insert(v7);
      insert(v0);
      insert(v2);
      insert(v6);
      insert(v0);
      insert(v6);
      return insert(v4);
    };
    for (x = i = -5; i <= 5; x = ++i) {
      for (y = j = -5; j <= 5; y = ++j) {
        for (z = k = -5; k <= 5; z = ++k) {
          if (x !== 0 || y !== 0 || z !== 0) {
            cube(x, y, z, 0.3);
          }
        }
      }
    }
    this.total_vertices = vertices.length / 6;
    GL.bindBuffer(GL.ARRAY_BUFFER, vertex_buffer);
    vertices_array = new Float32Array(vertices);
    GL.bufferData(GL.ARRAY_BUFFER, 4 * vertices_array.length, vertices_array, GL.STATIC_DRAW);
    GL.bindVertexArray(vertex_array);
    GL.enableVertexAttribArray(0);
    GL.enableVertexAttribArray(1);
    GL.bindBuffer(GL.ARRAY_BUFFER, vertex_buffer);
    GL.vertexAttribPointer(0, 3, GL.FLOAT, GL.FALSE, 24, 0);
    return GL.vertexAttribPointer(1, 3, GL.FLOAT, GL.FALSE, 24, 12);
  };

  setupRender = function() {
    compileShaders();
    return setupBuffers();
  };

  omni.onCaptureViewport(function() {
    GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
    GL.useProgram(program.id());
    omni.setUniforms(program.id());
    GL.bindVertexArray(vertex_array);
    return GL.drawArrays(GL.TRIANGLES, 0, total_vertices);
  });

  render = function() {
    var sz;
    omni.capture();
    sz = w.getFramebufferSize();
    omni.composite(0, 0, sz[0], sz[1]);
    return w.swapBuffers();
  };

  setupRender();

  render();

  w.onRefresh(render);

  timer = setInterval(function() {
    nav.update();
    render();
    return w.pollEvents();
  });

  w.onClose(function() {
    return clearInterval(timer);
  });

}).call(this);
