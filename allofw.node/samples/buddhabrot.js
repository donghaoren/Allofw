// Generated by CoffeeScript 1.10.0
(function() {
  var GL, allofw, compileShaders3, composite_fragment_shader, composite_vertex_shader, fragment_shader, geometry_shader, getProgramInfoLog, getShaderInfoLog, graphics, n, render, render_fractal, render_fractal_begin, setupBuffers, setupRender, timer, vertex_shader, w;

  allofw = require("allofw");

  GL = allofw.GL3;

  graphics = allofw.graphics;

  w = new allofw.OpenGLWindow({
    width: 600,
    height: 600
  });

  w.makeContextCurrent();

  vertex_shader = "#version 330\nuniform vec2 offset;\nuniform float rotation;\nlayout(location = 0) in vec2 c_input;\nout vec2 cs;\nvoid main() {\n    cs = c_input;\n    cs = vec2(cos(rotation) * cs.x + sin(rotation) * cs.y, -sin(rotation) * cs.x + cos(rotation) * cs.y);\n    cs += offset;\n}";

  geometry_shader = "#version 330\nlayout(points) in;\nlayout(points, max_vertices = 256) out;\n\nconst int max_iteration = 256;\n\nin vec2 cs[1];\n\nvoid main() {\n    vec2 c = cs[0];\n    vec2 z0 = vec2(0, 0);\n    vec2 z = z0;\n    int t = 0;\n    while(t < max_iteration) {\n        // z' = z^2 + c\n        z = vec2(z.x * z.x - z.y * z.y, z.x * z.y * 2.0) + c;\n        if(length(z) >= 2) break;\n        t += 1;\n    }\n    if(t < max_iteration) {\n        z = z0;\n        t = 0;\n        while(t < max_iteration) {\n            z = vec2(z.x * z.x - z.y * z.y, z.x * z.y * 2.0) + c;\n            if(length(z) >= 10) break;\n            if(t > 0) {\n                gl_Position = vec4(z / 2, 0, 1);\n                gl_Position.x += 0.2;\n                EmitVertex();\n            }\n            t += 1;\n        }\n    }\n}";

  fragment_shader = "#version 330\nlayout(location = 0) out vec4 fragment_output;\nvoid main() {\n    float v = 1;\n    fragment_output = vec4(v, v, v, 1);\n}";

  composite_vertex_shader = "#version 330\nuniform float x_scale;\nuniform float y_scale;\nlayout(location = 0) in vec2 pos;\nout vec2 tex_coord;\nvoid main() {\n    tex_coord = vec2(1.0 - pos.y, pos.x);\n    gl_Position = vec4(pos * 2.0 - 1.0, 0, 1);\n    gl_Position.x *= x_scale;\n    gl_Position.y *= y_scale;\n}";

  composite_fragment_shader = "#version 330\nuniform sampler2D texCounter;\nuniform sampler2D texColormap;\nuniform float max_counter;\nin vec2 tex_coord;\nlayout(location = 0) out vec4 fragment_output;\nvoid main() {\n    vec4 counter = texture(texCounter, tex_coord);\n    float v = counter.r / max_counter;\n    float p = 1 - exp(-v * 2);\n    fragment_output = texture(texColormap, vec2(p, 0.5));\n}";

  getShaderInfoLog = function(shader) {
    var buf, buffer, length;
    buffer = new Buffer(4);
    GL.getShaderiv(shader, GL.INFO_LOG_LENGTH, buffer);
    length = buffer.readUInt32LE(0);
    if (length > 0) {
      buf = new Buffer(length);
      GL.getShaderInfoLog(shader, length, buffer, buf);
      return buf.toString("utf-8");
    }
  };

  getProgramInfoLog = function(program) {
    var buf, buffer, length;
    buffer = new Buffer(4);
    GL.getProgramiv(program, GL.INFO_LOG_LENGTH, buffer);
    length = buffer.readUInt32LE(0);
    if (length > 0) {
      buf = new Buffer(length);
      GL.getProgramInfoLog(program, length, buffer, buf);
      return buf.toString("utf-8");
    } else {
      return null;
    }
  };

  compileShaders3 = function(vertex_shader, geometry_shader, fragment_shader) {
    var log, program, shader_f, shader_g, shader_v;
    shader_v = GL.createShader(GL.VERTEX_SHADER);
    GL.shaderSource(shader_v, [vertex_shader]);
    if (geometry_shader != null) {
      shader_g = GL.createShader(GL.GEOMETRY_SHADER);
      GL.shaderSource(shader_g, [geometry_shader]);
    }
    shader_f = GL.createShader(GL.FRAGMENT_SHADER);
    GL.shaderSource(shader_f, [fragment_shader]);
    program = GL.createProgram();
    GL.compileShader(shader_v);
    log = getShaderInfoLog(shader_v);
    if (log != null) {
      console.log(log);
    }
    if (geometry_shader != null) {
      GL.compileShader(shader_g);
      log = getShaderInfoLog(shader_g);
      if (log != null) {
        console.log(log);
      }
    }
    GL.compileShader(shader_f);
    log = getShaderInfoLog(shader_f);
    if (log != null) {
      console.log(log);
    }
    GL.attachShader(program, shader_v);
    if (geometry_shader != null) {
      GL.attachShader(program, shader_g);
    }
    GL.attachShader(program, shader_f);
    GL.linkProgram(program);
    log = getProgramInfoLog(program);
    if (log != null) {
      console.log(log);
    }
    return program;
  };

  setupBuffers = function() {
    var buffer, data, i, j, k, l, m, ref, ref1, ref2, s, samples_x, samples_y, x, y;
    this.vertex_buffer = new GL.Buffer();
    this.vertex_array = new GL.VertexArray();
    this.vertices = 0;
    samples_x = 200;
    samples_y = 200;
    this.xmin = -2;
    this.xmax = +2;
    this.ymin = -2;
    this.ymax = +2;
    this.cell_size_x = (xmax - xmin) / samples_x;
    this.cell_size_y = (ymax - ymin) / samples_y;
    data = [];
    for (i = k = 0, ref = samples_x - 1; 0 <= ref ? k <= ref : k >= ref; i = 0 <= ref ? ++k : --k) {
      for (j = l = 0, ref1 = samples_y - 1; 0 <= ref1 ? l <= ref1 : l >= ref1; j = 0 <= ref1 ? ++l : --l) {
        x = i / (samples_x - 1) * (xmax - xmin) + xmin;
        y = j / (samples_y - 1) * (ymax - ymin) + ymin;
        data.push(x);
        data.push(y);
        vertices += 1;
      }
    }
    console.log("Number of vertices:", vertices);
    buffer = new Buffer(4 * data.length);
    for (i = m = 0, ref2 = data.length - 1; 0 <= ref2 ? m <= ref2 : m >= ref2; i = 0 <= ref2 ? ++m : --m) {
      buffer.writeFloatLE(data[i], i * 4);
    }
    GL.bindBuffer(GL.ARRAY_BUFFER, vertex_buffer);
    GL.bufferData(GL.ARRAY_BUFFER, buffer.length, buffer, GL.STATIC_DRAW);
    GL.bindVertexArray(vertex_array);
    GL.enableVertexAttribArray(0);
    GL.bindBuffer(GL.ARRAY_BUFFER, vertex_buffer);
    GL.vertexAttribPointer(0, 2, GL.FLOAT, GL.FALSE, 8, 0);
    GL.bindBuffer(GL.ARRAY_BUFFER, 0);
    GL.bindVertexArray(0);
    this.framebuffer = new GL.Framebuffer();
    this.framebuffer_texture = new GL.Texture();
    this.framebuffer_size = 2048;
    GL.bindTexture(GL.TEXTURE_2D, framebuffer_texture);
    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MIN_FILTER, GL.LINEAR_MIPMAP_LINEAR);
    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_MAG_FILTER, GL.LINEAR);
    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_S, GL.CLAMP_TO_EDGE);
    GL.texParameteri(GL.TEXTURE_2D, GL.TEXTURE_WRAP_T, GL.CLAMP_TO_EDGE);
    GL.texImage2D(GL.TEXTURE_2D, 0, GL.RGBA32F, framebuffer_size, framebuffer_size, 0, GL.RGBA, GL.FLOAT, 0);
    GL.bindTexture(GL.TEXTURE_2D, 0);
    GL.bindFramebuffer(GL.FRAMEBUFFER, framebuffer);
    GL.framebufferTexture2D(GL.FRAMEBUFFER, GL.COLOR_ATTACHMENT0, GL.TEXTURE_2D, framebuffer_texture, 0);
    s = GL.checkFramebufferStatus(GL.FRAMEBUFFER);
    if (s !== GL.FRAMEBUFFER_COMPLETE) {
      console.log("Framebuffer incomplete:", s);
    }
    GL.bindFramebuffer(GL.FRAMEBUFFER, 0);
    this.quad_buffer = new GL.Buffer();
    this.quad_array = new GL.VertexArray();
    buffer = new Buffer(4 * 8);
    buffer.writeFloatLE(0, 0 * 4);
    buffer.writeFloatLE(0, 1 * 4);
    buffer.writeFloatLE(0, 2 * 4);
    buffer.writeFloatLE(1, 3 * 4);
    buffer.writeFloatLE(1, 4 * 4);
    buffer.writeFloatLE(0, 5 * 4);
    buffer.writeFloatLE(1, 6 * 4);
    buffer.writeFloatLE(1, 7 * 4);
    GL.bindBuffer(GL.ARRAY_BUFFER, quad_buffer);
    GL.bufferData(GL.ARRAY_BUFFER, buffer.length, buffer, GL.STATIC_DRAW);
    GL.bindVertexArray(quad_array);
    GL.enableVertexAttribArray(0);
    GL.bindBuffer(GL.ARRAY_BUFFER, quad_buffer);
    GL.vertexAttribPointer(0, 2, GL.FLOAT, GL.FALSE, 8, 0);
    GL.bindBuffer(GL.ARRAY_BUFFER, 0);
    GL.bindVertexArray(0);
    this.colormap_image = graphics.loadImageData(require("fs").readFileSync(__dirname + "/buddhabrot_colormap.png"));
    return colormap_image.uploadTexture();
  };

  setupRender = function() {
    this.program = compileShaders3(vertex_shader, geometry_shader, fragment_shader);
    this.program_composite = compileShaders3(composite_vertex_shader, void 0, composite_fragment_shader);
    GL.useProgram(program_composite);
    GL.uniform1i(GL.getUniformLocation(program_composite, "texCounter"), 0);
    GL.uniform1i(GL.getUniformLocation(program_composite, "texColormap"), 1);
    GL.useProgram(0);
    return setupBuffers();
  };

  render_fractal_begin = function() {
    GL.bindFramebuffer(GL.FRAMEBUFFER, framebuffer);
    GL.viewport(0, 0, framebuffer_size, framebuffer_size);
    GL.clear(GL.COLOR_BUFFER_BIT);
    return GL.bindFramebuffer(GL.FRAMEBUFFER, 0);
  };

  render_fractal = function() {
    var rotation, x, y;
    x = (Math.random() - 0.5) * cell_size_x;
    y = (Math.random() - 0.5) * cell_size_y;
    rotation = Math.random() * Math.PI * 2;
    GL.disable(GL.DEPTH_TEST);
    GL.depthMask(GL.FALSE);
    GL.bindFramebuffer(GL.FRAMEBUFFER, framebuffer);
    GL.viewport(0, 0, framebuffer_size, framebuffer_size);
    GL.enable(GL.BLEND);
    GL.blendFunc(GL.ONE, GL.ONE);
    GL.pointSize(1);
    GL.useProgram(program);
    GL.uniform2f(GL.getUniformLocation(program, "offset"), x, y);
    GL.uniform1f(GL.getUniformLocation(program, "rotation"), rotation);
    GL.bindVertexArray(vertex_array);
    GL.drawArrays(GL.POINTS, 0, vertices);
    GL.bindVertexArray(0);
    GL.useProgram(0);
    GL.bindFramebuffer(GL.FRAMEBUFFER, 0);
    GL.bindTexture(GL.TEXTURE_2D, framebuffer_texture);
    GL.generateMipmap(GL.TEXTURE_2D);
    return GL.bindTexture(GL.TEXTURE_2D, 0);
  };

  n = 0;

  render = function() {
    var err, sz, x_scale, y_scale;
    render_fractal();
    n += 1;
    sz = w.getFramebufferSize();
    GL.viewport(0, 0, sz[0], sz[1]);
    GL.useProgram(program_composite);
    GL.uniform1f(GL.getUniformLocation(program_composite, "max_counter"), n / 10);
    if (sz[0] < sz[1]) {
      y_scale = sz[0] / sz[1];
      x_scale = 1;
    } else {
      x_scale = sz[1] / sz[0];
      y_scale = 1;
    }
    GL.uniform1f(GL.getUniformLocation(program_composite, "y_scale"), y_scale);
    GL.uniform1f(GL.getUniformLocation(program_composite, "x_scale"), x_scale);
    GL.disable(GL.BLEND);
    GL.clear(GL.COLOR_BUFFER_BIT);
    GL.bindVertexArray(quad_array);
    GL.activeTexture(GL.TEXTURE0);
    GL.bindTexture(GL.TEXTURE_2D, framebuffer_texture);
    colormap_image.bindTexture(1);
    GL.drawArrays(GL.TRIANGLE_STRIP, 0, 4);
    colormap_image.unbindTexture(1);
    GL.activeTexture(GL.TEXTURE0);
    GL.bindTexture(GL.TEXTURE_2D, 0);
    GL.bindVertexArray(0);
    GL.useProgram(0);
    err = GL.getError();
    if (err !== 0) {
      console.log(err);
    }
    return w.swapBuffers();
  };

  setupRender();

  render_fractal_begin();

  render_fractal(0);

  render();

  w.onRefresh(render);

  timer = setInterval(function() {
    render();
    return w.pollEvents();
  });

  w.onClose(function() {
    return clearInterval(timer);
  });

}).call(this);
