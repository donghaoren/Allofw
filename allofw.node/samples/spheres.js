// Generated by CoffeeScript 1.10.0
(function() {
  var GL, allofw, allofwutils, compileShaders, getProgramInfoLog, getShaderInfoLog, nav, omni, render, setupBuffers, setupRender, sphereShader_FragmentCode, sphereShader_GeometryCode, sphereShader_VertexCode, timer, w;

  allofw = require("allofw");

  allofwutils = require("allofwutils");

  GL = allofw.GL3;

  w = new allofw.OpenGLWindow();

  w.makeContextCurrent();

  omni = new allofw.OmniStereo("allofw.yaml");

  nav = new allofwutils.WindowNavigation(w, omni);

  sphereShader_GeometryCode = "#version 330\n" + omni.getShaderCode() + "layout(points) in;\nlayout(triangle_strip, max_vertices = 50) out;\nin vec4 colors[1];\nin float radiuses[1];\nin vec3 positions[1];\n\nout vec4 color;\nout float radius;\nout vec3 center;\nout vec3 p_prime;\n\nvoid main() {\n    color = colors[0];\n    radius = radiuses[0];\n    center = positions[0];\n\n    int sides = 24;\n\n    float d = length(center);\n    if(d <= radius) return;\n\n    float x = radius * radius / d;\n    vec3 center_prime = center - center * (x / d);\n    float radius_prime = sqrt(radius * radius - x * x);\n    radius_prime /= cos(3.1415926535897932 / sides);\n    radius_prime *= 1.01;\n    vec3 up = vec3(0, 1, 1);\n    vec3 ex = normalize(cross(center, up));\n    vec3 ey = normalize(cross(ex, center));\n    ex *= radius_prime;\n    ey *= radius_prime;\n\n    vec3 p0 = center_prime + ex;\n\n    for(int i = 0; i <= sides; i++) {\n        float t = float(i) / sides * 3.1415926535897932 * 2;\n        vec3 p1 = center_prime + ex * cos(t) + ey * sin(t);\n\n        p_prime = center_prime; gl_Position = omni_render(p_prime); EmitVertex();\n        p_prime = p1; gl_Position = omni_render(p_prime); EmitVertex();\n    }\n    EndPrimitive();\n}";

  sphereShader_VertexCode = "#version 330\n" + omni.getShaderCode() + "layout(location = 0) in vec4 xyz_radius;\n\nout vec4 colors;\nout float radiuses;\nout vec3 positions;\n\nvoid main() {\n    colors = vec4(1, 1, 1, 1);\n    positions = omni_transform(xyz_radius.xyz);\n    radiuses = xyz_radius.w;\n}";

  sphereShader_FragmentCode = "#version 330\n" + omni.getShaderCode() + "uniform float specular_term = 20;\nuniform vec3 light_position = vec3(0, 0, 0);\nuniform vec4 light_ambient = vec4(0.3, 0.3, 0.3, 1.0);\nuniform vec4 light_diffuse = vec4(0.7, 0.7, 0.7, 1.0);\nuniform vec4 light_specular = vec4(1.0, 1.0, 1.0, 1.0);\n\nin vec4 color;\nin float radius;\nin vec3 center;\nin vec3 p_prime;\n\nlayout(location = 0) out vec4 fragment_color;\n\nvoid main() {\n    float qa = dot(p_prime, p_prime);\n    float qb = -2.0 * dot(p_prime, center);\n    float qc = dot(center, center) - radius * radius;\n    float qd = qb * qb - 4.0 * qa * qc;\n    if(qd <= 0.0) discard;\n    float t = (-qb - sqrt(qd)) / qa / 2.0;\n\n    vec3 p = p_prime * t;\n\n    vec3 N = normalize(p - center);\n    vec3 L = normalize(omni_transform(light_position) - p);\n    vec3 R = reflect(-L, N);\n\n    vec4 colorMixed = color;\n    vec4 final_color = colorMixed * light_ambient;\n\n    float lambertTerm = max(dot(N, L), 0.0);\n    final_color += light_diffuse * colorMixed * lambertTerm;\n    vec3 E = normalize(-p);\n    float spec = pow(max(dot(R, E), 0.0), specular_term);\n    final_color += light_specular * spec;\n    final_color.a = color.a;\n    final_color.rgb *= final_color.a;\n    fragment_color = final_color;\n\n    vec4 clip_position = omni_render(p);\n    vec3 pixel_position;\n    pixel_position.xy = clip_position.xy;\n    pixel_position.z = -clip_position.w;\n    pixel_position = pixel_position * (length(p) / length(pixel_position));\n    float z2 = pixel_position.z * omni_viewport_projection.z + omni_viewport_projection.w;\n    gl_FragDepth = (z2 / -pixel_position.z * 0.5 + 0.5);\n}";

  getShaderInfoLog = function(shader) {
    var buf, buffer, length;
    buffer = new Buffer(4);
    GL.getShaderiv(shader, GL.INFO_LOG_LENGTH, buffer);
    length = buffer.readUInt32LE(0);
    if (length > 0) {
      buf = new Buffer(length);
      GL.getShaderInfoLog(shader, length, buffer, buf);
      return buf.toString("utf-8");
    }
  };

  getProgramInfoLog = function(program) {
    var buf, buffer, length;
    buffer = new Buffer(4);
    GL.getProgramiv(program, GL.INFO_LOG_LENGTH, buffer);
    length = buffer.readUInt32LE(0);
    if (length > 0) {
      buf = new Buffer(length);
      GL.getProgramInfoLog(program, length, buffer, buf);
      return buf.toString("utf-8");
    } else {
      return null;
    }
  };

  compileShaders = function() {
    var log, shader_f, shader_g, shader_v;
    shader_v = GL.createShader(GL.VERTEX_SHADER);
    GL.shaderSource(shader_v, [sphereShader_VertexCode]);
    shader_g = GL.createShader(GL.GEOMETRY_SHADER);
    GL.shaderSource(shader_g, [sphereShader_GeometryCode]);
    shader_f = GL.createShader(GL.FRAGMENT_SHADER);
    GL.shaderSource(shader_f, [sphereShader_FragmentCode]);
    this.program = GL.createProgram();
    GL.compileShader(shader_v);
    log = getShaderInfoLog(shader_v);
    if (log != null) {
      console.log(log);
    }
    GL.compileShader(shader_g);
    log = getShaderInfoLog(shader_g);
    if (log != null) {
      console.log(log);
    }
    GL.compileShader(shader_f);
    log = getShaderInfoLog(shader_f);
    if (log != null) {
      console.log(log);
    }
    GL.attachShader(program, shader_v);
    GL.attachShader(program, shader_g);
    GL.attachShader(program, shader_f);
    GL.linkProgram(program);
    log = getProgramInfoLog(program);
    if (log != null) {
      return console.log(log);
    }
  };

  setupBuffers = function() {
    var i, idx, j, k, vertices, vertices_array, x, y, z;
    this.vertex_buffer = new GL.Buffer();
    this.vertex_array = new GL.VertexArray();
    vertices = [];
    idx = 0;
    for (x = i = -5; i <= -2; x = ++i) {
      for (y = j = -5; j <= -2; y = ++j) {
        for (z = k = -5; k <= -2; z = ++k) {
          if (x !== 0 || y !== 0 || z !== 0) {
            vertices[idx++] = x;
            vertices[idx++] = y;
            vertices[idx++] = z;
            vertices[idx++] = 0.8;
          }
        }
      }
    }
    this.total_vertices = vertices.length / 4;
    GL.bindBuffer(GL.ARRAY_BUFFER, vertex_buffer);
    vertices_array = new Float32Array(vertices);
    GL.bufferData(GL.ARRAY_BUFFER, 4 * vertices_array.length, vertices_array, GL.STATIC_DRAW);
    GL.bindVertexArray(vertex_array);
    GL.enableVertexAttribArray(0);
    GL.bindBuffer(GL.ARRAY_BUFFER, vertex_buffer);
    GL.vertexAttribPointer(0, 4, GL.FLOAT, GL.FALSE, 16, 0);
    GL.bindBuffer(GL.ARRAY_BUFFER, 0);
    return GL.bindVertexArray(0);
  };

  setupRender = function() {
    compileShaders();
    return setupBuffers();
  };

  omni.onCaptureViewport(function() {
    GL.clear(GL.COLOR_BUFFER_BIT | GL.DEPTH_BUFFER_BIT);
    GL.useProgram(program.id());
    omni.setUniforms(program.id());
    GL.bindVertexArray(vertex_array);
    return GL.drawArrays(GL.POINTS, 0, total_vertices);
  });

  render = function() {
    var sz;
    omni.capture();
    sz = w.getFramebufferSize();
    omni.composite(0, 0, sz[0], sz[1]);
    return w.swapBuffers();
  };

  setupRender();

  render();

  w.onRefresh(render);

  timer = setInterval(function() {
    nav.update();
    render();
    return w.pollEvents();
  });

  w.onClose(function() {
    return clearInterval(timer);
  });

}).call(this);
